// -*- C++ -*-
/**
 * \file ButtonController.tmpl
 * This file is part of LyX, the document processor.
 * Licence details can be found in the file COPYING.
 *
 * \author Allan Rae
 * \author Angus Leeming
 * \author Baruch Even
 *
 * Full author contact details are available in file CREDITS
 *
 * GuiBC is a base class and so these templatised methods will be
 * instantiated if this file is #included in the derived classes' .C file.
 */

#include "BCView.h"
#include "ButtonPolicies.h"
#include "debug.h"

namespace lyx {
namespace frontend {

template <class Button, class Widget>
GuiBC<Button, Widget>::GuiBC(ButtonController const & parent,
			     std::string const & cancel, std::string const & close)
	: BCView(parent),
	  cancel_label_(cancel), close_label_(close),
	  okay_(0), apply_(0), cancel_(0), restore_(0)
{}


template <class Button, class Widget>
void GuiBC<Button, Widget>::refresh() const
{
	lyxerr[Debug::GUI] << "Calling BC refresh()" << std::endl;

	bool const all_valid = checkWidgets();

	if (okay_) {
		bool const enabled =
			all_valid && bp().buttonStatus(ButtonPolicy::OKAY);
		setButtonEnabled(okay_, enabled);
	}
	if (apply_) {
		bool const enabled =
			all_valid && bp().buttonStatus(ButtonPolicy::APPLY);
		setButtonEnabled(apply_, enabled);
	}
	if (restore_) {
		bool const enabled =
			all_valid && bp().buttonStatus(ButtonPolicy::RESTORE);
		setButtonEnabled(restore_, enabled);
	}
	if (cancel_) {
		bool const enabled = bp().buttonStatus(ButtonPolicy::CANCEL);
		if (enabled)
			setButtonLabel(cancel_, cancel_label_);
		else
			setButtonLabel(cancel_, close_label_);
	}
}


template <class Button, class Widget>
void GuiBC<Button, Widget>::refreshReadOnly() const
{
	if (read_only_.empty()) return;

	bool const enable = !bp().isReadOnly();

	typename Widgets::const_iterator end = read_only_.end();
	typename Widgets::const_iterator iter = read_only_.begin();
	for (; iter != end; ++iter) {
		setWidgetEnabled(*iter, enable);
	}
}

} // namespace frontend
} // namespace lyx
