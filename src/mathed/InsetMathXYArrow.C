/**
 * \file InsetMathXYArrow.C
 * This file is part of LyX, the document processor.
 * Licence details can be found in the file COPYING.
 *
 * \author André Pönitz
 *
 * Full author contact details are available in file CREDITS.
 */

#include <config.h>

#include "InsetMathXYArrow.h"
#include "MathStream.h"
#include "MathSupport.h"
#include "frontends/Painter.h"
#include "debug.h"


namespace lyx {


using std::max;


InsetMathXYArrow::InsetMathXYArrow()
	: InsetMathNest(2)
{}


std::auto_ptr<InsetBase> InsetMathXYArrow::clone() const
{
	return std::auto_ptr<InsetBase>(new InsetMathXYArrow(*this));
}


InsetMathXYMatrix const * InsetMathXYArrow::targetMatrix() const
{
	return target_;
}


MathArray const & InsetMathXYArrow::targetCell() const
{
#if 0
	InsetMathXYMatrix const * p = targetMatrix();
	int x = 0;
	int y = 0;
	MathArray const & t = cell(0);
	for (MathArray::const_iterator it = t.begin(); it != t.end(); ++it) {
		switch ((*it)->getChar()) {
			case 'l': --x; break;
			case 'r': ++x; break;
			case 'u': --y; break;
			case 'd': ++y; break;
		}
	}
	//lyxerr << "target: x: " << x << " y: " << y << endl;
	InsetMath::idx_type n = mi_.idx + p->ncols() * y + x;
	if (n >= p->nargs()) {
		lyxerr << "source: n: " << mi_.idx << "\n"
		       << "target: n: " << n << " out of range" << endl;
		n = 0;
	}
	return p->cell(n);
#else
	static MathArray dummy;
	return dummy;
#endif
}


MathArray const & InsetMathXYArrow::sourceCell() const
{
#if 0
	return targetMatrix()->cell(mi_.idx);
#else
	static MathArray dummy;
	return dummy;
#endif
}


void InsetMathXYArrow::metrics(MetricsInfo & mi) const
{
	InsetMathNest::metrics(mi);
	mi_   = mi;
	FontSetChanger dummy(mi.base, "textrm");
#if 0
	target_ = mi.inset ? mi.inset->asXYMatrixInset() : 0;

	if (editing()) {
		int w    = mathed_string_width(mi.base.font, from_ascii("target: "));
		width_   = w + max(cell(0).width(), cell(1).width());
		ascent_  = cell(0).ascent();
		descent_ = cell(0).descent() + cell(1).height() + 10;
	} else {
		width_   = 0;
		ascent_  = 0;
		descent_ = 0;
		//mathed_string_dim(font_, "X", ascent_, descent_, width_);
	}
#endif
}


void InsetMathXYArrow::draw(PainterInfo & pi, int x, int y) const
{
	metrics(mi_);
	FontSetChanger dummy(pi.base, "textrm");

	if (editing()) {

#if 0

		int lasc;
		int ldes;
		int lwid;
		mathed_string_dim(pi.base.font, "target: ", lasc, ldes, lwid);

		cell(0).draw(pi, x + lwid, y);
		pi.base.text(x + 3, y, "target");
		y += max(cell(0).descent(), ldes) + 5;

		y += max(cell(1).ascent(), lasc) + 5;
		cell(1).draw(pi, x + lwid, y);
		pi.base.text(x + 3, y, "label");

#endif

	} else {

		pi.pain.text(x, y, "X");
		MathArray const & s = sourceCell();
		MathArray const & t = targetCell();
		pi.pain.line(s.xm(), s.ym(), t.xm(), t.ym(), LColor::math);
		cell(1).draw(pi, (s.xm() + t.xm())/2, (s.ym() + t.ym())/2);

	}
}


void InsetMathXYArrow::write(WriteStream & os) const
{
	os << "\\ar";
	if (cell(0).size())
		os << '[' << cell(0) << ']';
	if (cell(1).size())
		os << (up_ ? '^' : '_') << '{' << cell(1) << '}';
	os << " ";
}


void InsetMathXYArrow::normalize(NormalStream & os) const
{
	os << "[xyarrow ";
	InsetMathNest::normalize(os);
	os << ']';
}


} // namespace lyx
